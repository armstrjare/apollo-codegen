{"version":3,"sources":["../src/cli.js"],"names":["on","error","handleError","exit","command","output","demand","describe","default","normalize","coerce","resolve","header","alias","type","arg","additionalHeaders","split","name","value","argv","outputPath","server","schema","target","choices","inputPaths","input","map","options","passthroughCustomScalars","tsNamespace","tsNamespaceType","match","fail","message","help","version","strict"],"mappings":"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","file":"cli.js","sourcesContent":["\n\nimport process from 'process';\nimport path from 'path';\nimport yargs from 'yargs';\n\nimport { downloadSchema, generate } from '.';\nimport { ToolError, logError } from './errors'\n\nimport 'source-map-support/register'\n\n// Make sure unhandled errors in async code are propagated correctly\nprocess.on('unhandledRejection', (error) => { throw error });\n\nprocess.on('uncaughtException', handleError);\n\nfunction handleError(error) {\n  logError(error);\n  process.exit(1);\n}\n\nyargs\n  .command(\n    'download-schema <server>',\n    'Download a GraphQL schema from a server',\n    {\n      output: {\n        demand: true,\n        describe: 'Output path for GraphQL schema file',\n        default: 'schema.json',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      header: {\n        alias: 'H',\n        describe: 'Additional header to send to the server as part of the introspection query request',\n        type: 'array',\n        coerce: (arg) => {\n          let additionalHeaders = {};\n          for (const header of arg) {\n            const [name, value] = header.split(/\\s*:\\s*/);\n            if (!(name && value)) {\n              throw new ToolError('Headers should be specified as \"Name: Value\"');\n            }\n            additionalHeaders[name] = value;\n          }\n          return additionalHeaders;\n        }\n      },\n    },\n    async argv => {\n      const outputPath = path.resolve(argv.output);\n      const additionalHeaders = argv.header;\n      await downloadSchema(argv.server, outputPath, additionalHeaders);\n    }\n  )\n  .command(\n    'generate [input...]',\n    'Generate code from a GraphQL schema and query documents',\n    {\n      schema: {\n        demand: true,\n        describe: 'Path to GraphQL schema file',\n        default: 'schema.json',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      output: {\n        describe: 'Output directory for the generated files',\n        normalize: true,\n        coerce: path.resolve,\n      },\n      target: {\n        demand: false,\n        describe: 'Code generation target language',\n        choices: ['swift', 'json', 'ts', 'typescript', 'flow'],\n        default: 'swift'\n      },\n      \"passthrough-custom-scalars\": {\n        demand: false,\n        describe: \"Don't attempt to map custom scalars [temporary option]\",\n        default: false\n      },\n      \"ts-namespace\": {\n        demand: false,\n        describe: \"Typescript: An [optional] namespace name for generated types.\",\n        default: null\n      },\n      \"ts-namespace-type\": {\n        demand: false,\n        describe: \"Typescript: How the namespace should be generated. Either `export` or `declare`.\" +\n                  \"Defaults to `export`, unless the `output` path ends in `.d.ts`, in which case it deafults to `declare`.\",\n        default: null\n      }\n    },\n    argv => {\n      const inputPaths = argv.input.map(input => path.resolve(input));\n\n      const options = {\n        passthroughCustomScalars: argv[\"passthrough-custom-scalars\"],\n        tsNamespace: argv[\"ts-namespace\"],\n        tsNamespaceType: (argv[\"ts-namespace-type\"] || (argv[\"ts-namespace\"] && argv.output.match(/\\.d\\.ts$/) ? \"declare\" : \"export\"))\n      };\n      generate(inputPaths, argv.schema, argv.output, argv.target, options);\n    },\n  )\n  .fail(function(message, error) {\n    handleError(error ? error : new ToolError(message));\n  })\n  .help()\n  .version()\n  .strict()\n  .argv\n"]}