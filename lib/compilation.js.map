{"version":3,"sources":["../src/compilation.js"],"names":["compileToIR","printIR","schema","document","compiler","Compiler","operations","forEach","operation","name","value","compileOperation","fragments","fragment","compileFragment","typesUsed","typesUsedSet","fragmentMap","definitions","definition","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","compiledFragmentMap","type","add","getFields","field","addTypeUsed","fragmentName","operationDefinition","operationName","operationType","variables","variableDefinitions","map","node","variable","source","withTypenameFieldAddedWhereNeeded","rootType","groupedVisitedFragmentSet","groupedFieldSet","collectFields","selectionSet","undefined","fragmentsReferencedSet","resolveFields","fields","fragmentsReferenced","fragmentDefinition","typeCondition","fragmentSpreads","inlineFragments","parentType","Error","String","selections","selection","FIELD","fieldName","responseName","alias","directives","INLINE_FRAGMENT","inlineFragmentType","effectiveType","FRAGMENT_SPREAD","fragmentNamed","fragmentType","visitedFragmentSet","get","set","fieldSet","filter","length","firstField","isConditional","some","directiveName","directive","bareType","subSelectionGroupedVisitedFragmentSet","subSelectionGroupedFieldSet","mergeSelectionSets","fragmentSpreadsForParentType","resolveInlineFragments","values","fragmentsReferencedFromFragment","fragmentReferenced","collectPossibleTypes","possibleTypes","isPossibleType","keys","typenameField","NAME","ast","typeInfo","leave","SelectionSet","getParentType","sourceAt","location","body","slice","start","end","concat","inlineFragment"],"mappings":"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","file":"compilation.js","sourcesContent":["import {\n  print,\n  visit,\n  visitWithTypeInfo,\n  typeFromAST,\n  getNamedType,\n  isAbstractType,\n  isEqualType,\n  isTypeSubTypeOf,\n  Kind,\n  TypeInfo,\n  isType,\n  isCompositeType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLError\n} from 'graphql';\n\nimport {\n  isTypeProperSuperTypeOf,\n  getOperationRootType,\n  getFieldDef\n} from './utilities/graphql';\n\nimport {\n  join,\n  block,\n  wrap,\n  indent\n} from './utilities/printing';\n\n// Parts of this code are adapted from graphql-js\n\nexport function compileToIR(schema, document) {\n  const compiler = new Compiler(schema, document);\n\n  const operations = Object.create(null);\n\n  compiler.operations.forEach(operation => {\n    operations[operation.name.value] = compiler.compileOperation(operation)\n  });\n\n  const fragments = Object.create(null);\n\n  compiler.fragments.forEach(fragment => {\n    fragments[fragment.name.value] = compiler.compileFragment(fragment)\n  });\n\n  const typesUsed = compiler.typesUsed;\n\n  return { schema, operations, fragments, typesUsed };\n}\n\nexport class Compiler {\n  constructor(schema, document) {\n    this.schema = schema;\n\n    this.typesUsedSet = new Set();\n\n    this.fragmentMap = Object.create(null);\n    this.operations = [];\n\n    for (const definition of document.definitions) {\n      switch (definition.kind) {\n        case Kind.OPERATION_DEFINITION:\n          this.operations.push(definition);\n          break;\n        case Kind.FRAGMENT_DEFINITION:\n          this.fragmentMap[definition.name.value] = definition;\n          break;\n      }\n    }\n\n    this.compiledFragmentMap = Object.create(null);\n  }\n\n  addTypeUsed(type) {\n    if (type instanceof GraphQLEnumType || type instanceof GraphQLInputObjectType) {\n      this.typesUsedSet.add(type);\n    }\n    if (type instanceof GraphQLInputObjectType) {\n      for (const field of Object.values(type.getFields())) {\n        this.addTypeUsed(getNamedType(field.type));\n      }\n    }\n  }\n\n  get typesUsed() {\n    return Array.from(this.typesUsedSet);\n  }\n\n  fragmentNamed(fragmentName) {\n    return this.fragmentMap[fragmentName];\n  }\n\n  get fragments() {\n    return Object.values(this.fragmentMap);\n  }\n\n  compileOperation(operationDefinition) {\n    const operationName = operationDefinition.name.value;\n    const operationType = operationDefinition.operation;\n\n    const variables = operationDefinition.variableDefinitions.map(node => {\n      const name = node.variable.name.value;\n      const type = typeFromAST(this.schema, node.type);\n      this.addTypeUsed(getNamedType(type));\n      return { name, type };\n    });\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, operationDefinition));\n\n    const rootType = getOperationRootType(this.schema, operationDefinition);\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(rootType, operationDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields } = this.resolveFields(rootType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { operationName, operationType, variables, source, fields, fragmentsReferenced };\n  }\n\n  compileFragment(fragmentDefinition) {\n    const fragmentName = fragmentDefinition.name.value;\n\n    const source = print(withTypenameFieldAddedWhereNeeded(this.schema, fragmentDefinition));\n\n    const typeCondition = typeFromAST(this.schema, fragmentDefinition.typeCondition);\n\n    const groupedVisitedFragmentSet = new Map();\n    const groupedFieldSet = this.collectFields(typeCondition, fragmentDefinition.selectionSet, undefined, groupedVisitedFragmentSet);\n\n    const fragmentsReferencedSet = Object.create(null);\n    const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(typeCondition, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n    const fragmentsReferenced = Object.keys(fragmentsReferencedSet);\n\n    return { fragmentName, source, typeCondition, fields, fragmentSpreads, inlineFragments, fragmentsReferenced };\n  }\n\n  collectFields(parentType, selectionSet, groupedFieldSet = Object.create(null), groupedVisitedFragmentSet = new Map()) {\n    if (!isCompositeType(parentType)) {\n      throw new Error(`parentType should be a composite type, but is \"${String(parentType)}\"`);\n    }\n\n    for (const selection of selectionSet.selections) {\n      switch (selection.kind) {\n        case Kind.FIELD: {\n          const fieldName = selection.name.value;\n          const responseName = selection.alias ? selection.alias.value : fieldName;\n\n          const field = getFieldDef(this.schema, parentType, selection);\n          if (!field) {\n            throw new GraphQLError(`Cannot query field \"${fieldName}\" on type \"${String(parentType)}\"`, [selection]);\n          }\n\n          if (groupedFieldSet) {\n            if (!groupedFieldSet[responseName]) {\n              groupedFieldSet[responseName] = [];\n            }\n\n            groupedFieldSet[responseName].push([parentType, { responseName, fieldName, type: field.type, directives: selection.directives, selectionSet: selection.selectionSet }]);\n          }\n          break;\n        }\n        case Kind.INLINE_FRAGMENT: {\n          const typeCondition = selection.typeCondition;\n          const inlineFragmentType = typeCondition ?\n            typeFromAST(this.schema, typeCondition) :\n            parentType;\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : inlineFragmentType;\n\n          this.collectFields(\n            effectiveType,\n            selection.selectionSet,\n            groupedFieldSet,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n        case Kind.FRAGMENT_SPREAD: {\n          const fragmentName = selection.name.value;\n\n          const fragment = this.fragmentNamed(fragmentName);\n          if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n\n          const typeCondition = fragment.typeCondition;\n          const fragmentType = typeFromAST(this.schema, typeCondition)\n\n          if (groupedVisitedFragmentSet) {\n            let visitedFragmentSet = groupedVisitedFragmentSet.get(parentType);\n            if (!visitedFragmentSet) {\n              visitedFragmentSet = {};\n              groupedVisitedFragmentSet.set(parentType, visitedFragmentSet);\n            }\n\n            if (visitedFragmentSet[fragmentName]) continue;\n            visitedFragmentSet[fragmentName] = true;\n          }\n\n          const effectiveType = parentType instanceof GraphQLObjectType ? parentType : fragmentType;\n\n          this.collectFields(\n            effectiveType,\n            fragment.selectionSet,\n            null,\n            groupedVisitedFragmentSet\n          );\n          break;\n        }\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  mergeSelectionSets(parentType, fieldSet, groupedVisitedFragmentSet) {\n    const groupedFieldSet = Object.create(null);\n\n    for (const [,field] of fieldSet) {\n      const selectionSet = field.selectionSet;\n\n      if (selectionSet) {\n        this.collectFields(parentType, selectionSet, groupedFieldSet, groupedVisitedFragmentSet);\n      }\n    }\n\n    return groupedFieldSet;\n  }\n\n  resolveFields(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    const fields = [];\n\n    for (let [responseName, fieldSet] of Object.entries(groupedFieldSet)) {\n      fieldSet = fieldSet.filter(([typeCondition,]) => isTypeSubTypeOf(this.schema, parentType, typeCondition));\n      if (fieldSet.length < 1) continue;\n\n      const [,firstField] = fieldSet[0];\n      const fieldName = firstField.fieldName;\n      const type = firstField.type;\n\n      let field = { responseName, fieldName, type };\n\n      const isConditional = fieldSet.some(([,field]) => {\n        return field.directives && field.directives.some(directive => {\n          const directiveName = directive.name.value;\n          return directiveName == 'skip' || directiveName == 'include';\n        });\n      });\n\n      if (isConditional) {\n        field.isConditional = true;\n      }\n\n      const bareType = getNamedType(type);\n\n      this.addTypeUsed(bareType);\n\n      if (isCompositeType(bareType)) {\n        const subSelectionGroupedVisitedFragmentSet = new Map();\n        const subSelectionGroupedFieldSet = this.mergeSelectionSets(\n          bareType,\n          fieldSet,\n          subSelectionGroupedVisitedFragmentSet\n        );\n\n        const { fields, fragmentSpreads, inlineFragments } = this.resolveFields(\n          bareType,\n          subSelectionGroupedFieldSet,\n          subSelectionGroupedVisitedFragmentSet,\n          fragmentsReferencedSet\n        );\n        Object.assign(field, { fields, fragmentSpreads, inlineFragments });\n      }\n\n      fields.push(field);\n    }\n\n    const fragmentSpreads = this.fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet);\n    const inlineFragments = this.resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet);\n\n    if (fragmentsReferencedSet) {\n      Object.assign(fragmentsReferencedSet, ...groupedVisitedFragmentSet.values());\n\n      // TODO: This is a really inefficient way of keeping track of fragments referenced by other fragments\n      // We need to either cache compiled fragments or find a way to make resolveFields smarter\n      for (let fragmentName of fragmentSpreads) {\n        const fragment = this.fragmentNamed(fragmentName);\n        if (!fragment) throw new GraphQLError(`Cannot find fragment \"${fragmentName}\"`);\n        const { fragmentsReferenced: fragmentsReferencedFromFragment } = this.compileFragment(fragment);\n        for (let fragmentReferenced of fragmentsReferencedFromFragment) {\n          fragmentsReferencedSet[fragmentReferenced] = true;\n        }\n      }\n    }\n\n    return { fields, fragmentSpreads, inlineFragments };\n  }\n\n  resolveInlineFragments(parentType, groupedFieldSet, groupedVisitedFragmentSet, fragmentsReferencedSet) {\n    return this.collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet).map(typeCondition => {\n      const { fields, fragmentSpreads } = this.resolveFields(\n        typeCondition,\n        groupedFieldSet,\n        groupedVisitedFragmentSet,\n        fragmentsReferencedSet\n      );\n      return { typeCondition, fields, fragmentSpreads };\n    });\n  }\n\n  collectPossibleTypes(parentType, groupedFieldSet, groupedVisitedFragmentSet) {\n    if (!isAbstractType(parentType)) return [];\n\n    const possibleTypes = new Set();\n\n    for (const fieldSet of Object.values(groupedFieldSet)) {\n      for (const [typeCondition,] of fieldSet) {\n        if (this.schema.isPossibleType(parentType, typeCondition)) {\n          possibleTypes.add(typeCondition);\n        }\n      }\n    }\n\n    // Also include type conditions for fragment spreads\n    if (groupedVisitedFragmentSet) {\n      for (const effectiveType of groupedVisitedFragmentSet.keys()) {\n        if (this.schema.isPossibleType(parentType, effectiveType)) {\n          possibleTypes.add(effectiveType);\n        }\n      }\n    }\n\n    return Array.from(possibleTypes);\n  }\n\n  fragmentSpreadsForParentType(parentType, groupedVisitedFragmentSet) {\n    if (!groupedVisitedFragmentSet) return [];\n\n    let fragmentSpreads = new Set();\n\n    for (const [effectiveType, visitedFragmentSet] of groupedVisitedFragmentSet) {\n      if (!isTypeProperSuperTypeOf(this.schema, effectiveType, parentType)) continue;\n\n      for (const fragmentName of Object.keys(visitedFragmentSet)) {\n        fragmentSpreads.add(fragmentName);\n      }\n    }\n\n    return Array.from(fragmentSpreads);\n  }\n}\n\nconst typenameField = { kind: Kind.FIELD, name: { kind: Kind.NAME, value: '__typename' } };\n\nfunction withTypenameFieldAddedWhereNeeded(schema, ast) {\n  const typeInfo = new TypeInfo(schema);\n\n  return visit(ast, visitWithTypeInfo(typeInfo, {\n    leave: {\n      SelectionSet: node => {\n        const parentType = typeInfo.getParentType();\n\n        if (isAbstractType(parentType)) {\n          return { ...node, selections: [typenameField, ...node.selections] };\n        }\n      }\n    }\n  }));\n}\n\nfunction sourceAt(location) {\n  return location.source.body.slice(location.start, location.end);\n}\n\nexport function printIR({ fields, inlineFragments, fragmentSpreads }) {\n  return fields && wrap('<', join(fragmentSpreads, ', '), '> ')\n    + block(fields.map(field =>\n      `${field.name}: ${String(field.type)}` + wrap(' ', printIR(field))\n    ).concat(inlineFragments && inlineFragments.map(inlineFragment =>\n      `${String(inlineFragment.typeCondition)}` + wrap(' ', printIR(inlineFragment)))));\n}\n"]}